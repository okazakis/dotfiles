module subprogs
  implicit none
contains
  
  ! ========== ガウス・ジョルダン法 ==========
  subroutine gauss_jordan_pv(a0, x, b, n)
    ! 1 本目の方程式を a(1,1) で割り、a(1,1) a係数をなくす
    ! この演算子における a(1,1) をピボット(pivot)という
    integer, intent(in)   :: n               ! 配列の寸法
    real(8), intent(in)   :: a0(n, n), b(n)  ! 形状明示仮配列
    real(8), intent(out)  :: x(n)            ! 形状明示仮配列
    integer                  i, k, m         ! 作業変数
    real(8)                  ar, am, t, a(n, n), w(n)     ! 作業変数
    
    a(:, :) = a0(:, :)    ! 係数行列 a0 を a にコピー
    x(:)    = b(:)        ! 右辺ベクトル b を x にコピー

    do k = 1, n
       ! ----- 部分 pivot 選択
       m = k
       am = abs(a(k, k))
       do i = k + 1, n       ! a(i, k) の絶対値が最大となる m 行を探す
          if (abs(a(i, k)) > am) then
             am = abs(a(i, k))
             m = i
          endif
       enddo
       if (am == 0.0D0) stop 'A is singular' ! A が特異行列なら停止
       if (k /= m) then                      ! k 行と m 行の入れ替え
          W(   k:n) = a(k, k:n)
          a(k, k:m) = a(m, k:n)
          a(m, k:n) = w(   k:n)
          t    = x(k)
          x(k) = x(m)
          x(m) = t
       endif
       ! ----- 以下, 通常のガウス・ジョルダン法
       ar = 1.0D0 / a(k, k)              ! ar は対角成分の逆数
       a(k, k)      = 1.0D0              ! 対角成分に 1 を設定
       a(k, k+1:n)  = ar * a(k, k+1:n)   ! k 行の k+1 列から n 列に ar を掛ける
       x(k)         = ar * x(k)          ! k 行の右辺にも ar を掛ける
       do i = 1, n
          if (i /=k ) then ! i 行の k から n 列の要素と x(i) に対する演算
             a(i, k+1:n) = a(i, k+1:n) - a(i, k) * a(k ,k+1:n)
             x(i)        = x(i)        - a(i, k) * x(k)
             a(i, k    ) = 0.0D0
          endif
       enddo
    enddo
  end subroutine gauss_jordan_pv

  ! ========== 係数を乱数で設定する ==========
  subroutine set_random_ab(a,b,x,n)
    implicit none
    real(8), allocatable, intent(out) :: a(:,:), b(:), x(:)
    integer n
    write(*,'(a)',advance='no')' input n: '
    read (*,*) n
    if (n < 1.or.n > 100) stop 'n must be 0 < n <101 '
    allocate (a(n,n))
    call random_number(a)
    allocate (b(n))
    call random_number(b)
    allocate (x(n))
  end subroutine set_random_ab

  ! ========== 係数を自分で設定する ==========
    subroutine set_ab(a,b,x,n)
    implicit none
    real(8), allocatable, intent(out) :: a(:,:), b(:), x(:)
    integer n
    n = 3
!    allocate (a(n,n))
    a(1, 1:3) = (/ 1.0d0, 4.0d0, 2.0d0 /)
    a(2, 1:3) = (/ 2.0d0, 1.0d0, 10.0d0 /)
    a(3, 1:3) = (/ 3.0d0, 5.0d0, 6.0d0 /)
!    allocate (b(n))
    b(1:3) = (/ 2.0d0, 1.0d0, 4.0d0 /)
    allocate (x(n))
  end subroutine set_ab

  ! ========== 係数行列の表示 ===========
  subroutine print_mat(a,b,n)
    implicit none
    real(8) a(n,n), b(n)
    integer i, j, n
    do i = 1, n
       do j = 1, n
          write(*,*) 'a(', i, ',', j, ')=', a(i,j)
       enddo
       write(*,*) 'b(', i, ')=', b(i)
    enddo
  end subroutine print_mat
  
end module subprogs

! 以上, サブルーチン
! ----------------------------------------
! 以下, メインプログラム

program main
  use subprogs
  implicit none
  ! ----- 変数設定 -----
  real(8),allocatable :: a(:,:),b(:),x(:),r(:)
  integer n, i 
  ! ----- サブルーチン呼び出し -----
  call set_ab(a,b,x,n)
  call set_random_ab(a,b,x,n)
  call print_mat(a,b,n)
  call gauss_jordan_pv(a,x,b,n)
  ! ----- 解の表示 -----
  write(*,*) '----------- solution ----------'
  allocate (r(n))
  do i = 1, n
     write(*,*) 'x', i, '=', x(i)
  enddo
  ! ----- 残差ベクトルの 2 乗和の表示 -----
  r(:)=b(:)-matmul(a,x)
  write(*,*) 'Gauss-Jordan error = ',dot_product(r,r)
  deallocate(a,b,x)     ! 割付解除
end program main   
