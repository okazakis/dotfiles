!*****************************************************************************
!* Program of linear 1D advection problem
!*
program advect1D

  !* Use statements
  use dc_types
  use gtool_history
  
  implicit none

  !* Parameters  -----------------------------------------------------------
  
  integer, parameter      :: Nx            =  200        ! Number of division
  real(DP), parameter     :: DelTime       =  0.0002_DP

  ! U1, U3 : 1st or 3rd order upwind diffrence
  ! C2     : 2nd order central diffrence
  character(3), parameter :: FDMType    =  'U1' 

  ! FE      : forward Euler
  ! BE      : backward Euler
  ! CN      : Crank-Nicolson
  ! AB2     : 2nd-order Adams-Bashforth
  character(3), parameter :: TMType    =  'FE' 
  

 
  real(DP), parameter :: OutputDelTime = 0.1_DP  
  real(DP), parameter :: EndTime       = 1.0_DP
  real(DP), parameter :: L             = 1.0_DP    ! Domain size  
  real(DP), parameter :: U             = 1.0_DP    ! Advective velocity
  
  character(TOKEN), parameter :: InitFuncForm = 'GAUSSIAN'
  real(DP), parameter :: gaussWidth = 0.05_DP*L
  !*************************************************************************
  
  !- Declaration of variables ----------------------------------------------
  
  integer, parameter :: IMAX = Nx + 1
  integer, parameter :: NMAX = EndTime / DelTime
  real(DP) :: x(IMAX)
  real(DP) :: qN(-1:IMAX+1), qA(-1:IMAX+1)
  real(DP) :: qRHSN(IMAX,2), qRHSB(IMAX,2)
  real(DP) :: ImplMat(IMAX,IMAX)
  integer  :: IPIV(IMAX), info
  real(DP) :: DelX
  real(DP) :: time
  integer  :: i
  integer  :: n

  !**********************************************************************
  
  call setup()

  write(*,*) '-- Start -- [FDMType=', FDMType, ', TMType=', TMType, ']'

  !--- Start time loop ----------------------------------------------------
  do n = 1, NMAX
     
     if(mod(n, int(0.1*NMAX)) == 0) then
        write(*,*) 'time=', time
     end if
     
     !* Set quantity in halo regions
     qN(-1:0) = qN(IMAX-2:IMAX-1);     
     qN(IMax+1) = qN(2)
     
     select case(TMType)
     case('BE')
     case Default
        select case(FDMType)
        case('U1')
           do i=1, IMAX-1
              qRHSN(i,1) = - U * ( qN(  i) - qN(i-1) ) / DelX 
           end do
        case('C2')
           do i=1, IMAX-1
              qRHSN(i,1) = - U * ( qN(i+1) - qN(i-1) ) / (2.0_DP*DelX)
           end do
        case('U3')
           do i=1, IMAX-1
              qRHSN(i,1) = - U * (   2.0_DP*qN(i+1) + 3.0_DP*qN(  i)                   &
                    &              - 6.0_DP*qN(i-1) +        qN(i-2) ) / (6.0_DP*DelX)
           end do
        case default
           write(*,*) trim(FDMType), ' is unimplemented. Check!'
           stop        
        end select
     end select

     select case(TMType)
     case('FE')
        qA(1:IMAX-1) = qN(1:IMAX-1) + DelTime*qRHSN(1:IMAX-1,1)        
     case('BE')
        qA(1:IMAX-1) = qN(1:IMAX-1);
        qA(IMAX) = 0.0_DP
        call dgetrs('N', IMAX, 1, ImplMat, IMAX, IPIV, qA(1:IMAX), IMAX, info)
     case('CN')
        qA(1:IMAX-1) = qN(1:IMAX-1) + 0.5_DP*DelTime*qRHSN(1:IMAX-1,1);
        qA(IMAX) = 0.0_DP
        call dgetrs('N', IMAX, 1, ImplMat, IMAX, IPIV, qA(1:IMAX), IMAX, info)
     case('AB2')
        if(n == 1) then
           qA(1:IMAX-1) = qN(1:IMAX-1) + DelTime*qRHSN(1:IMAX-1,1)
        else
           qA(1:IMAX-1) = qN(1:IMAX-1) &
                & + DelTime*(1.5_DP*qRHSN(1:IMAX-1,1) - 0.5_DP*qRHSB(1:IMAX-1,1))
        end if
     end select


     !* Update variables to advance next time step ********************************
     !
     
     time = time + DelTime     
     qN(:)    = qA(:)
     qRHSB    = qRHSN

     !* Apply periodic boundary condition *****************************************
     qN(IMax) = qN(1)
     

     !* Check numerical error*****************************************************
     if( abs(U*time - L) < 1d-9 ) then
        write(*,*) 'L2 error norm=', &
             & getL2ErrorNorm( &
             &  getFuncVal( x - 0.5_DP*L ), qN(1:IMAX) &
             & ), 'time=', time
     end if
     
     !* Output data to NetCDF ***************************************************
     if( mod(n, int(OutputDelTime/DelTime)) == 0 ) then
        write(*,*) '- Output', time
        call HistoryPut('q', qN(1:IMAX))
     end if
  end do
  !---------- End of time loop ------------------------------------------------------

  
  call shutdown()
  
contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  subroutine setup()

    integer :: i
    real(DP) :: c, dt_
    integer :: i_(-1:IMAX+1)

    ! Set initial time
    time = 0.0_DP

    ! Set x coordinate
    
    DelX = L/dble(Nx)
    do i = 1, IMAX
       x(i) = (i - 1)* DelX
    end do
    
    ! Preparation to output data
    call HistoryCreate( & 
         & file= 'result.nc', title='1D advection problem', &
         & source='Sample program of 1D advection problem',  &
         & institution='ITPASS',                             &
         & dims=(/'x', 't'/), dimsizes=(/ IMAX, 0 /),        &
         & longnames=(/'x', 't'/), units=(/ '1', '1'  /),    &
         & origin=real(time), interval=real(OutputDelTime) )

    call HistoryPut('x', x)
    
    call HistoryAddVariable( &
         & varname='q', dims=(/'x','t'/), &
         & longname='q', units='1' )

    ! Set initial condition
    
    qN(1:IMAX) = getFuncVal(x - 0.5_DP*L)
    call HistoryPut('q', qN(1:IMAX))

    ! Construct matrix for implicit solver
    !
    
    ImplMat(:,:) = 0.0_DP
    ImplMat(IMax,1) = -1.0_DP; ImplMat(IMax,IMax) = 1.0_DP
    do i = lbound(i_,1),ubound(i_,1)
       i_(i) = i
       if(i > IMax) i_(i) = i - IMax + 1
       if(i <    1) i_(i) = IMAX + i - 1
    end do
    
    select case(TMType)
    case('CN')
       dt_ = 0.5_DP*DelTime
    case Default
       dt_ = DelTime
    end select
    
    select case(FDMType)
    case('C2')
       c = U*dt_/(2.0_DP*DelX)
       do i=1, IMAX
          ImplMat(i,i_(i-1)) = -c
          ImplMat(i,i_(  i)) = 1.0_DP 
          ImplMat(i,i_(i+1)) = c 
       end do
       call dgetrf(IMAX,IMAX,ImplMat,IMAX,IPIV,INFO)
       write(*,*) "detrf INFO=", INFO
    case('U1')
       c = U*dt_/DelX
       do i=1, IMAX
          ImplMat(i,i_(i-1)) = -c
          ImplMat(i,i_(  i)) = 1.0_DP + c
       end do
       ImplMat(1,IMAX-1) = - c;  ImplMat(1,1) = 1.0_DP + c;       
       call dgetrf(IMAX,IMAX,ImplMat,IMAX,IPIV,INFO)
       write(*,*) "detrf INFO=", INFO
    case('U3')
       c = U*dt_/(6.0_DP*DelX)
       do i=1, IMAX
          ImplMat(i,i_(i-2)) = c
          ImplMat(i,i_(i-1)) = -6.0_DP*c
          ImplMat(i,i_(  i)) = 1.0_DP + 3.0_DP*c
          ImplMat(i,i_(i+1)) = 2.0_DP*c          
       end do       
       call dgetrf(IMAX,IMAX,ImplMat,IMAX,IPIV,INFO)
       write(*,*) "detrf INFO=", INFO       
    end select

  end subroutine setup

  subroutine shutdown()

    ! Close data file
    call HistoryClose()
    
  end subroutine shutdown

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function getFuncVal(x) result(val)
    real(DP), intent(in) :: x(IMAX)
    real(DP) :: val(IMAX)

    select case(InitFuncForm)
    case('GAUSSIAN')
       val(:) = exp(- (x/gaussWidth)**2 )
    case default
       write(*,*) InitFuncForm, ' is not surpported. Check!'
    end select
    
  end function getFuncVal

  function getL2ErrorNorm(anasol, numsol) result(L2ErrorNorm)
    real(DP), intent(in) :: anasol(IMAX), numsol(IMAX)
    real(DP) :: L2ErrorNorm

    L2ErrorNorm = sqrt(sum(( anasol - numsol )**2)) / sum(anasol)
    
  end function getL2ErrorNorm

end program advect1D
  
